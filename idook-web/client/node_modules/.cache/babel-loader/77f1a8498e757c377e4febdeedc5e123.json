{"ast":null,"code":"var _wrapNativeSuper = require(\"/home/thabataganga/Documentos/GITHUB/idook/idook/idook-web/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _slicedToArray = require(\"/home/thabataganga/Documentos/GITHUB/idook/idook/idook-web/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/thabataganga/Documentos/GITHUB/idook/idook/idook-web/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/home/thabataganga/Documentos/GITHUB/idook/idook/idook-web/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/home/thabataganga/Documentos/GITHUB/idook/idook/idook-web/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/thabataganga/Documentos/GITHUB/idook/idook/idook-web/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/home/thabataganga/Documentos/GITHUB/idook/idook/idook-web/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _createSuper = require(\"/home/thabataganga/Documentos/GITHUB/idook/idook/idook-web/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _inherits = require(\"/home/thabataganga/Documentos/GITHUB/idook/idook/idook-web/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\n/*\nCSV Stringify\n\nPlease look at the [project documentation](https://csv.js.org/stringify/) for\nadditional information.\n*/\nvar _require = require('stream'),\n    Transform = _require.Transform;\n\nvar bom_utf8 = Buffer.from([239, 187, 191]);\n\nvar Stringifier = /*#__PURE__*/function (_Transform) {\n  \"use strict\";\n\n  _inherits(Stringifier, _Transform);\n\n  var _super = _createSuper(Stringifier);\n\n  function Stringifier() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Stringifier);\n\n    _this = _super.call(this, _objectSpread({}, {\n      writableObjectMode: true\n    }, {}, opts));\n    var options = {};\n    var err; // Merge with user options\n\n    for (var opt in opts) {\n      options[underscore(opt)] = opts[opt];\n    }\n\n    if (err = _this.normalize(options)) throw err;\n\n    switch (options.record_delimiter) {\n      case 'auto':\n        options.record_delimiter = null;\n        break;\n\n      case 'unix':\n        options.record_delimiter = \"\\n\";\n        break;\n\n      case 'mac':\n        options.record_delimiter = \"\\r\";\n        break;\n\n      case 'windows':\n        options.record_delimiter = \"\\r\\n\";\n        break;\n\n      case 'ascii':\n        options.record_delimiter = \"\\x1E\";\n        break;\n\n      case 'unicode':\n        options.record_delimiter = \"\\u2028\";\n        break;\n    } // Expose options\n\n\n    _this.options = options; // Internal state\n\n    _this.state = {\n      stop: false\n    }; // Information\n\n    _this.info = {\n      records: 0\n    };\n\n    if (options.bom === true) {\n      _this.push(bom_utf8);\n    }\n\n    _assertThisInitialized(_this);\n\n    return _this;\n  }\n\n  _createClass(Stringifier, [{\n    key: \"normalize\",\n    value: function normalize(options) {\n      // Normalize option `bom`\n      if (options.bom === undefined || options.bom === null || options.bom === false) {\n        options.bom = false;\n      } else if (options.bom !== true) {\n        return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', ['option `bom` is optional and must be a boolean value,', \"got \".concat(JSON.stringify(options.bom))]);\n      } // Normalize option `delimiter`\n\n\n      if (options.delimiter === undefined || options.delimiter === null) {\n        options.delimiter = ',';\n      } else if (Buffer.isBuffer(options.delimiter)) {\n        options.delimiter = options.delimiter.toString();\n      } else if (typeof options.delimiter !== 'string') {\n        return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', ['option `delimiter` must be a buffer or a string,', \"got \".concat(JSON.stringify(options.delimiter))]);\n      } // Normalize option `quote`\n\n\n      if (options.quote === undefined || options.quote === null) {\n        options.quote = '\"';\n      } else if (options.quote === true) {\n        options.quote = '\"';\n      } else if (options.quote === false) {\n        options.quote = '';\n      } else if (Buffer.isBuffer(options.quote)) {\n        options.quote = options.quote.toString();\n      } else if (typeof options.quote !== 'string') {\n        return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', ['option `quote` must be a boolean, a buffer or a string,', \"got \".concat(JSON.stringify(options.quote))]);\n      } // Normalize option `quoted`\n\n\n      if (options.quoted === undefined || options.quoted === null) {\n        options.quoted = false;\n      } else {} // todo\n      // Normalize option `quoted_empty`\n\n\n      if (options.quoted_empty === undefined || options.quoted_empty === null) {\n        options.quoted_empty = undefined;\n      } else {} // todo\n      // Normalize option `quoted_match`\n\n\n      if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {\n        options.quoted_match = null;\n      } else if (!Array.isArray(options.quoted_match)) {\n        options.quoted_match = [options.quoted_match];\n      }\n\n      if (options.quoted_match) {\n        var _iterator = _createForOfIteratorHelper(options.quoted_match),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var quoted_match = _step.value;\n            var isString = typeof quoted_match === 'string';\n            var isRegExp = quoted_match instanceof RegExp;\n\n            if (!isString && !isRegExp) {\n              return Error(\"Invalid Option: quoted_match must be a string or a regex, got \".concat(JSON.stringify(quoted_match)));\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } // Normalize option `quoted_string`\n\n\n      if (options.quoted_string === undefined || options.quoted_string === null) {\n        options.quoted_string = false;\n      } else {} // todo\n      // Normalize option `eof`\n\n\n      if (options.eof === undefined || options.eof === null) {\n        options.eof = true;\n      } else {} // todo\n      // Normalize option `escape`\n\n\n      if (options.escape === undefined || options.escape === null) {\n        options.escape = '\"';\n      } else if (Buffer.isBuffer(options.escape)) {\n        options.escape = options.escape.toString();\n      } else if (typeof options.escape !== 'string') {\n        return Error(\"Invalid Option: escape must be a buffer or a string, got \".concat(JSON.stringify(options.escape)));\n      }\n\n      if (options.escape.length > 1) {\n        return Error(\"Invalid Option: escape must be one character, got \".concat(options.escape.length, \" characters\"));\n      } // Normalize option `header`\n\n\n      if (options.header === undefined || options.header === null) {\n        options.header = false;\n      } else {} // todo\n      // Normalize option `columns`\n\n\n      options.columns = this.normalize_columns(options.columns); // Normalize option `quoted`\n\n      if (options.quoted === undefined || options.quoted === null) {\n        options.quoted = false;\n      } else {} // todo\n      // Normalize option `cast`\n\n\n      if (options.cast === undefined || options.cast === null) {\n        options.cast = {};\n      } else {} // todo\n      // Normalize option cast.bigint\n\n\n      if (options.cast.bigint === undefined || options.cast.bigint === null) {\n        // Cast boolean to string by default\n        options.cast.bigint = function (value) {\n          return '' + value;\n        };\n      } // Normalize option cast.boolean\n\n\n      if (options.cast.boolean === undefined || options.cast.boolean === null) {\n        // Cast boolean to string by default\n        options.cast.boolean = function (value) {\n          return value ? '1' : '';\n        };\n      } // Normalize option cast.date\n\n\n      if (options.cast.date === undefined || options.cast.date === null) {\n        // Cast date to timestamp string by default\n        options.cast.date = function (value) {\n          return '' + value.getTime();\n        };\n      } // Normalize option cast.number\n\n\n      if (options.cast.number === undefined || options.cast.number === null) {\n        // Cast number to string using native casting by default\n        options.cast.number = function (value) {\n          return '' + value;\n        };\n      } // Normalize option cast.object\n\n\n      if (options.cast.object === undefined || options.cast.object === null) {\n        // Stringify object as JSON by default\n        options.cast.object = function (value) {\n          return JSON.stringify(value);\n        };\n      } // Normalize option cast.string\n\n\n      if (options.cast.string === undefined || options.cast.string === null) {\n        // Leave string untouched\n        options.cast.string = function (value) {\n          return value;\n        };\n      } // Normalize option `record_delimiter`\n\n\n      if (options.record_delimiter === undefined || options.record_delimiter === null) {\n        options.record_delimiter = '\\n';\n      } else if (Buffer.isBuffer(options.record_delimiter)) {\n        options.record_delimiter = options.record_delimiter.toString();\n      } else if (typeof options.record_delimiter !== 'string') {\n        return Error(\"Invalid Option: record_delimiter must be a buffer or a string, got \".concat(JSON.stringify(options.record_delimiter)));\n      }\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      if (this.state.stop === true) {\n        return;\n      } // Chunk validation\n\n\n      if (!Array.isArray(chunk) && typeof chunk !== 'object') {\n        this.state.stop = true;\n        return callback(Error(\"Invalid Record: expect an array or an object, got \".concat(JSON.stringify(chunk))));\n      } // Detect columns from the first record\n\n\n      if (this.info.records === 0) {\n        if (Array.isArray(chunk)) {\n          if (this.options.header === true && !this.options.columns) {\n            this.state.stop = true;\n            return callback(Error('Undiscoverable Columns: header option requires column option or object records'));\n          }\n        } else if (this.options.columns === undefined || this.options.columns === null) {\n          this.options.columns = this.normalize_columns(Object.keys(chunk));\n        }\n      } // Emit the header\n\n\n      if (this.info.records === 0) {\n        this.headers();\n      } // Emit and stringify the record if an object or an array\n\n\n      try {\n        this.emit('record', chunk, this.info.records);\n      } catch (err) {\n        this.state.stop = true;\n        return this.emit('error', err);\n      } // Convert the record into a string\n\n\n      if (this.options.eof) {\n        chunk = this.stringify(chunk);\n\n        if (chunk === undefined) {\n          return;\n        } else {\n          chunk = chunk + this.options.record_delimiter;\n        }\n      } else {\n        chunk = this.stringify(chunk);\n\n        if (chunk === undefined) {\n          return;\n        } else {\n          if (this.options.header || this.info.records) {\n            chunk = this.options.record_delimiter + chunk;\n          }\n        }\n      } // Emit the csv\n\n\n      this.info.records++;\n      this.push(chunk);\n      callback();\n      null;\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.info.records === 0) {\n        this.headers();\n      }\n\n      callback();\n      null;\n    }\n  }, {\n    key: \"stringify\",\n    value: function stringify(chunk) {\n      var _this2 = this;\n\n      var chunkIsHeader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (typeof chunk !== 'object') {\n        return chunk;\n      }\n\n      var _this$options = this.options,\n          columns = _this$options.columns,\n          header = _this$options.header;\n      var record = []; // Record is an array\n\n      if (Array.isArray(chunk)) {\n        // We are getting an array but the user has specified output columns. In\n        // this case, we respect the columns indexes\n        if (columns) {\n          chunk.splice(columns.length);\n        } // Cast record elements\n\n\n        for (var _i = 0; _i < chunk.length; _i++) {\n          var field = chunk[_i];\n\n          var _this$__cast = this.__cast(field, {\n            index: _i,\n            column: _i,\n            records: this.info.records,\n            header: chunkIsHeader\n          }),\n              _this$__cast2 = _slicedToArray(_this$__cast, 2),\n              err = _this$__cast2[0],\n              value = _this$__cast2[1];\n\n          if (err) {\n            this.emit('error', err);\n            return;\n          }\n\n          record[_i] = [value, field];\n        } // Record is a literal object\n\n      } else {\n        if (columns) {\n          for (var _i2 = 0; _i2 < columns.length; _i2++) {\n            var _field = get(chunk, columns[_i2].key);\n\n            var _this$__cast3 = this.__cast(_field, {\n              index: _i2,\n              column: columns[_i2].key,\n              records: this.info.records,\n              header: chunkIsHeader\n            }),\n                _this$__cast4 = _slicedToArray(_this$__cast3, 2),\n                _err = _this$__cast4[0],\n                _value = _this$__cast4[1];\n\n            if (_err) {\n              this.emit('error', _err);\n              return;\n            }\n\n            record[_i2] = [_value, _field];\n          }\n        } else {\n          var _iterator2 = _createForOfIteratorHelper(chunk),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var column = _step2.value;\n              var _field2 = chunk[column];\n\n              var _this$__cast5 = this.__cast(_field2, {\n                index: i,\n                column: columns[i].key,\n                records: this.info.records,\n                header: chunkIsHeader\n              }),\n                  _this$__cast6 = _slicedToArray(_this$__cast5, 2),\n                  _err2 = _this$__cast6[0],\n                  _value2 = _this$__cast6[1];\n\n              if (_err2) {\n                this.emit('error', _err2);\n                return;\n              }\n\n              record.push([_value2, _field2]);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      }\n\n      var csvrecord = '';\n\n      var _loop = function _loop(_i3) {\n        var options = void 0,\n            err = void 0;\n\n        var _record$_i = _slicedToArray(record[_i3], 2),\n            value = _record$_i[0],\n            field = _record$_i[1];\n\n        if (typeof value === \"string\") {\n          options = _this2.options;\n        } else if (isObject(value)) {\n          // let { value, ...options } = value\n          options = value;\n          value = options.value;\n          delete options.value;\n\n          if (typeof value !== \"string\" && value !== undefined && value !== null) {\n            _this2.emit(\"error\", Error(\"Invalid Casting Value: returned value must return a string, null or undefined, got \".concat(JSON.stringify(value))));\n\n            return {\n              v: void 0\n            };\n          }\n\n          options = _objectSpread({}, _this2.options, {}, options);\n\n          if (err = _this2.normalize(options)) {\n            _this2.emit(\"error\", err);\n\n            return {\n              v: void 0\n            };\n          }\n        } else if (value === undefined || value === null) {\n          options = _this2.options;\n        } else {\n          _this2.emit(\"error\", Error(\"Invalid Casting Value: returned value must return a string, an object, null or undefined, got \".concat(JSON.stringify(value))));\n\n          return {\n            v: void 0\n          };\n        }\n\n        var _options = options,\n            delimiter = _options.delimiter,\n            escape = _options.escape,\n            quote = _options.quote,\n            quoted = _options.quoted,\n            quoted_empty = _options.quoted_empty,\n            quoted_string = _options.quoted_string,\n            quoted_match = _options.quoted_match,\n            record_delimiter = _options.record_delimiter;\n\n        if (value) {\n          if (typeof value !== 'string') {\n            _this2.emit(\"error\", Error(\"Formatter must return a string, null or undefined, got \".concat(JSON.stringify(value))));\n\n            return {\n              v: null\n            };\n          }\n\n          var containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;\n          var containsQuote = quote !== '' && value.indexOf(quote) >= 0;\n          var containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n          var containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n          var quotedString = quoted_string && typeof field === 'string';\n          var quotedMatch = quoted_match && quoted_match.filter(function (quoted_match) {\n            if (typeof quoted_match === 'string') {\n              return value.indexOf(quoted_match) !== -1;\n            } else {\n              return quoted_match.test(value);\n            }\n          });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          var shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;\n\n          if (shouldQuote === true && containsEscape === true) {\n            var regexp = escape === '\\\\' ? new RegExp(escape + escape, 'g') : new RegExp(escape, 'g');\n            value = value.replace(regexp, escape + escape);\n          }\n\n          if (containsQuote === true) {\n            var _regexp = new RegExp(quote, 'g');\n\n            value = value.replace(_regexp, escape + quote);\n          }\n\n          if (shouldQuote === true) {\n            value = quote + value + quote;\n          }\n\n          csvrecord += value;\n        } else if (quoted_empty === true || field === '' && quoted_string === true && quoted_empty !== false) {\n          csvrecord += quote + quote;\n        }\n\n        if (_i3 !== record.length - 1) {\n          csvrecord += delimiter;\n        }\n      };\n\n      for (var _i3 = 0; _i3 < record.length; _i3++) {\n        var _ret = _loop(_i3);\n\n        if (typeof _ret === \"object\") return _ret.v;\n      }\n\n      return csvrecord;\n    }\n  }, {\n    key: \"headers\",\n    value: function headers() {\n      if (this.options.header === false) {\n        return;\n      }\n\n      if (this.options.columns === undefined) {\n        return;\n      }\n\n      var headers = this.options.columns.map(function (column) {\n        return column.header;\n      });\n\n      if (this.options.eof) {\n        headers = this.stringify(headers, true) + this.options.record_delimiter;\n      } else {\n        headers = this.stringify(headers);\n      }\n\n      this.push(headers);\n    }\n  }, {\n    key: \"__cast\",\n    value: function __cast(value, context) {\n      var type = typeof value;\n\n      try {\n        if (type === 'string') {\n          // Fine for 99% of the cases\n          return [undefined, this.options.cast.string(value, context)];\n        } else if (type === 'bigint') {\n          return [undefined, this.options.cast.bigint(value, context)];\n        } else if (type === 'number') {\n          return [undefined, this.options.cast.number(value, context)];\n        } else if (type === 'boolean') {\n          return [undefined, this.options.cast.boolean(value, context)];\n        } else if (value instanceof Date) {\n          return [undefined, this.options.cast.date(value, context)];\n        } else if (type === 'object' && value !== null) {\n          return [undefined, this.options.cast.object(value, context)];\n        } else {\n          return [undefined, value, value];\n        }\n      } catch (err) {\n        return [err];\n      }\n    }\n  }, {\n    key: \"normalize_columns\",\n    value: function normalize_columns(columns) {\n      if (columns === undefined || columns === null) {\n        return undefined;\n      }\n\n      if (typeof columns !== 'object') {\n        throw Error('Invalid option \"columns\": expect an array or an object');\n      }\n\n      if (!Array.isArray(columns)) {\n        var newcolumns = [];\n\n        for (var k in columns) {\n          newcolumns.push({\n            key: k,\n            header: columns[k]\n          });\n        }\n\n        columns = newcolumns;\n      } else {\n        var _newcolumns = [];\n\n        var _iterator3 = _createForOfIteratorHelper(columns),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var column = _step3.value;\n\n            if (typeof column === 'string') {\n              _newcolumns.push({\n                key: column,\n                header: column\n              });\n            } else if (typeof column === 'object' && column !== undefined && !Array.isArray(column)) {\n              if (!column.key) {\n                throw Error('Invalid column definition: property \"key\" is required');\n              }\n\n              if (column.header === undefined) {\n                column.header = column.key;\n              }\n\n              _newcolumns.push(column);\n            } else {\n              throw Error('Invalid column definition: expect a string or an object');\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        columns = _newcolumns;\n      }\n\n      return columns;\n    }\n  }]);\n\n  return Stringifier;\n}(Transform);\n\nvar stringify = function stringify() {\n  var data, options, callback;\n\n  for (var _i4 in arguments) {\n    var argument = arguments[_i4];\n    var type = typeof argument;\n\n    if (data === undefined && Array.isArray(argument)) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', \"got \".concat(JSON.stringify(argument), \" at index \").concat(_i4)]);\n    }\n  }\n\n  var stringifier = new Stringifier(options);\n\n  if (callback) {\n    var chunks = [];\n    stringifier.on('readable', function () {\n      var chunk;\n\n      while ((chunk = this.read()) !== null) {\n        chunks.push(chunk);\n      }\n    });\n    stringifier.on('error', function (err) {\n      callback(err);\n    });\n    stringifier.on('end', function () {\n      callback(undefined, chunks.join(''));\n    });\n  }\n\n  if (data !== undefined) {\n    // Give a chance for events to be registered later\n    if (typeof setImmediate === 'function') {\n      setImmediate(function () {\n        var _iterator4 = _createForOfIteratorHelper(data),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var record = _step4.value;\n            stringifier.write(record);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        stringifier.end();\n      });\n    } else {\n      var _iterator5 = _createForOfIteratorHelper(data),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var record = _step5.value;\n          stringifier.write(record);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      stringifier.end();\n    }\n  }\n\n  return stringifier;\n};\n\nvar CsvError = /*#__PURE__*/function (_Error) {\n  \"use strict\";\n\n  _inherits(CsvError, _Error);\n\n  var _super2 = _createSuper(CsvError);\n\n  function CsvError(code, message) {\n    var _this3;\n\n    _classCallCheck(this, CsvError);\n\n    if (Array.isArray(message)) message = message.join(' ');\n    _this3 = _super2.call(this, message);\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(_assertThisInitialized(_this3), CsvError);\n    }\n\n    _this3.code = code;\n\n    for (var _len = arguments.length, contexts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      contexts[_key - 2] = arguments[_key];\n    }\n\n    for (var _i5 = 0, _contexts = contexts; _i5 < _contexts.length; _i5++) {\n      var context = _contexts[_i5];\n\n      for (var key in context) {\n        var value = context[key];\n        _this3[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n\n    return _this3;\n  }\n\n  return CsvError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nstringify.Stringifier = Stringifier;\nstringify.CsvError = CsvError;\nmodule.exports = stringify;\n\nvar isObject = function isObject(obj) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nvar underscore = function underscore(str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n}; // Lodash implementation of `get`\n\n\nvar charCodeOfDot = '.'.charCodeAt(0);\nvar reEscapeChar = /\\\\(\\\\)?/g;\nvar rePropName = RegExp( // Match anything that isn't a dot or bracket.\n'[^.[\\\\]]+' + '|' + // Or match property names within brackets.\n'\\\\[(?:' + // Match a non-string expression.\n'([^\"\\'][^[]*)' + '|' + // Or match strings (supports escaping characters).\n'([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' + ')\\\\]' + '|' + // Or match \"\" as the space between consecutive dots or empty brackets.\n'(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))', 'g');\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nvar reIsPlainProp = /^\\w*$/;\n\nvar getTag = function getTag(value) {\n  if (!value) value === undefined ? '[object Undefined]' : '[object Null]';\n  return Object.prototype.toString.call(value);\n};\n\nvar isKey = function isKey(value, object) {\n  if (Array.isArray(value)) {\n    return false;\n  }\n\n  var type = typeof value;\n\n  if (type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)) {\n    return true;\n  }\n\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n};\n\nvar isSymbol = function isSymbol(value) {\n  var type = typeof value;\n  return type === 'symbol' || type === 'object' && value && getTag(value) === '[object Symbol]';\n};\n\nvar stringToPath = function stringToPath(string) {\n  var result = [];\n\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push('');\n  }\n\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    var key = match;\n\n    if (quote) {\n      key = subString.replace(reEscapeChar, '$1');\n    } else if (expression) {\n      key = expression.trim();\n    }\n\n    result.push(key);\n  });\n  return result;\n};\n\nvar castPath = function castPath(value, object) {\n  if (Array.isArray(value)) {\n    return value;\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value);\n  }\n};\n\nvar toKey = function toKey(value) {\n  if (typeof value === 'string' || isSymbol(value)) return value;\n  var result = \"\".concat(value);\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n};\n\nvar get = function get(object, path) {\n  path = castPath(path, object);\n  var index = 0;\n  var length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n\n  return index && index === length ? object : undefined;\n};","map":{"version":3,"sources":["/home/thabataganga/Documentos/GITHUB/idook/idook/idook-web/client/node_modules/csv-stringify/lib/index.js"],"names":["require","Transform","bom_utf8","Buffer","from","Stringifier","opts","writableObjectMode","options","err","opt","underscore","normalize","record_delimiter","state","stop","info","records","bom","push","undefined","CsvError","JSON","stringify","delimiter","isBuffer","toString","quote","quoted","quoted_empty","quoted_match","Array","isArray","isString","isRegExp","RegExp","Error","quoted_string","eof","escape","length","header","columns","normalize_columns","cast","bigint","value","boolean","date","getTime","number","object","string","chunk","encoding","callback","Object","keys","headers","emit","chunkIsHeader","record","splice","i","field","__cast","index","column","get","key","csvrecord","isObject","containsdelimiter","indexOf","containsQuote","containsEscape","containsRecordDelimiter","quotedString","quotedMatch","filter","test","shouldQuote","regexp","replace","map","context","type","Date","newcolumns","k","data","arguments","argument","stringifier","chunks","on","read","join","setImmediate","write","end","code","message","captureStackTrace","contexts","parse","module","exports","obj","str","_","match","toLowerCase","charCodeOfDot","charCodeAt","reEscapeChar","rePropName","reIsDeepProp","reIsPlainProp","getTag","prototype","call","isKey","isSymbol","stringToPath","result","expression","subString","trim","castPath","toKey","INFINITY","path"],"mappings":"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","sourcesContent":["\n/*\nCSV Stringify\n\nPlease look at the [project documentation](https://csv.js.org/stringify/) for\nadditional information.\n*/\n\nconst { Transform } = require('stream')\nconst bom_utf8 = Buffer.from([239, 187, 191])\n\nclass Stringifier extends Transform {\n  constructor(opts = {}){\n    super({...{writableObjectMode: true}, ...opts})\n    const options = {}\n    let err\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    if(err = this.normalize(options)) throw err\n    switch(options.record_delimiter){\n      case 'auto':\n        options.record_delimiter = null\n        break\n      case 'unix':\n        options.record_delimiter = \"\\n\"\n        break\n      case 'mac':\n        options.record_delimiter = \"\\r\"\n        break\n      case 'windows':\n        options.record_delimiter = \"\\r\\n\"\n        break\n      case 'ascii':\n        options.record_delimiter = \"\\u001e\"\n        break\n      case 'unicode':\n        options.record_delimiter = \"\\u2028\"\n        break\n    }\n    // Expose options\n    this.options = options\n    // Internal state\n    this.state = {\n      stop: false\n    }\n    // Information\n    this.info = {\n      records: 0\n    }\n    if(options.bom === true){\n      this.push(bom_utf8)\n    }\n    this\n  }\n  normalize(options){\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', [\n        'option `bom` is optional and must be a boolean value,',\n        `got ${JSON.stringify(options.bom)}`\n      ])\n    }\n    // Normalize option `delimiter`\n    if(options.delimiter === undefined || options.delimiter === null){\n      options.delimiter = ','\n    }else if(Buffer.isBuffer(options.delimiter)){\n      options.delimiter = options.delimiter.toString()\n    }else if(typeof options.delimiter !== 'string'){\n      return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', [\n        'option `delimiter` must be a buffer or a string,',\n        `got ${JSON.stringify(options.delimiter)}`\n      ])\n    }\n    // Normalize option `quote`\n    if(options.quote === undefined || options.quote === null){\n      options.quote = '\"'\n    }else if(options.quote === true){\n      options.quote = '\"'\n    }else if(options.quote === false){\n      options.quote = ''\n    }else if (Buffer.isBuffer(options.quote)){\n      options.quote = options.quote.toString()\n    }else if(typeof options.quote !== 'string'){\n      return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', [\n        'option `quote` must be a boolean, a buffer or a string,',\n        `got ${JSON.stringify(options.quote)}`\n      ])\n    }\n    // Normalize option `quoted`\n    if(options.quoted === undefined || options.quoted === null){\n      options.quoted = false\n    }else{\n      // todo\n    }\n    // Normalize option `quoted_empty`\n    if(options.quoted_empty === undefined || options.quoted_empty === null){\n      options.quoted_empty = undefined\n    }else{\n      // todo\n    }\n    // Normalize option `quoted_match`\n    if(options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false){\n      options.quoted_match = null\n    }else if(!Array.isArray(options.quoted_match)){\n      options.quoted_match = [options.quoted_match]\n    }\n    if(options.quoted_match){\n      for(let quoted_match of options.quoted_match){\n        const isString = typeof quoted_match === 'string'\n        const isRegExp = quoted_match instanceof RegExp\n        if(!isString && !isRegExp){\n          return Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)\n        }\n      }\n    }\n    // Normalize option `quoted_string`\n    if(options.quoted_string === undefined || options.quoted_string === null){\n      options.quoted_string = false\n    }else{\n      // todo\n    }\n    // Normalize option `eof`\n    if(options.eof === undefined || options.eof === null){\n      options.eof = true\n    }else{\n      // todo\n    }\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === null){\n      options.escape = '\"'\n    }else if(Buffer.isBuffer(options.escape)){\n      options.escape = options.escape.toString()\n    }else if(typeof options.escape !== 'string'){\n      return Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)\n    }\n    if (options.escape.length > 1){\n      return Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)\n    }\n    // Normalize option `header`\n    if(options.header === undefined || options.header === null){\n      options.header = false\n    }else{\n      // todo\n    }\n    // Normalize option `columns`\n    options.columns = this.normalize_columns(options.columns)\n    // Normalize option `quoted`\n    if(options.quoted === undefined || options.quoted === null){\n      options.quoted = false\n    }else{\n      // todo\n    }\n    // Normalize option `cast`\n    if(options.cast === undefined || options.cast === null){\n      options.cast = {}\n    }else{\n      // todo\n    }\n    // Normalize option cast.bigint\n    if(options.cast.bigint === undefined || options.cast.bigint === null){\n      // Cast boolean to string by default\n      options.cast.bigint = value => '' + value\n    }\n    // Normalize option cast.boolean\n    if(options.cast.boolean === undefined || options.cast.boolean === null){\n      // Cast boolean to string by default\n      options.cast.boolean = value => value ? '1' : ''\n    }\n    // Normalize option cast.date\n    if(options.cast.date === undefined || options.cast.date === null){\n      // Cast date to timestamp string by default\n      options.cast.date = value => '' + value.getTime()\n    }\n    // Normalize option cast.number\n    if(options.cast.number === undefined || options.cast.number === null){\n      // Cast number to string using native casting by default\n      options.cast.number = value => '' + value\n    }\n    // Normalize option cast.object\n    if(options.cast.object === undefined || options.cast.object === null){\n      // Stringify object as JSON by default\n      options.cast.object = value => JSON.stringify(value)\n    }\n    // Normalize option cast.string\n    if(options.cast.string === undefined || options.cast.string === null){\n      // Leave string untouched\n      options.cast.string = function(value){return value}\n    }\n    // Normalize option `record_delimiter`\n    if(options.record_delimiter === undefined || options.record_delimiter === null){\n      options.record_delimiter = '\\n'\n    }else if(Buffer.isBuffer(options.record_delimiter)){\n      options.record_delimiter = options.record_delimiter.toString()\n    }else if(typeof options.record_delimiter !== 'string'){\n      return Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)\n    }\n  }\n  _transform(chunk, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    // Chunk validation\n    if(!Array.isArray(chunk) && typeof chunk !== 'object'){\n      this.state.stop = true\n      return callback(Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`))\n    }\n    // Detect columns from the first record\n    if(this.info.records === 0){\n      if(Array.isArray(chunk)){\n        if(this.options.header === true && !this.options.columns){\n          this.state.stop = true\n          return callback(Error('Undiscoverable Columns: header option requires column option or object records'))\n        }\n      }else if(this.options.columns === undefined || this.options.columns === null){\n        this.options.columns = this.normalize_columns(Object.keys(chunk))\n      }\n    }\n    // Emit the header\n    if(this.info.records === 0){\n      this.headers()\n    }\n    // Emit and stringify the record if an object or an array\n    try{\n      this.emit('record', chunk, this.info.records)\n    }catch(err){\n      this.state.stop = true\n      return this.emit('error', err)\n    }\n    // Convert the record into a string\n    if(this.options.eof){\n      chunk = this.stringify(chunk)\n      if(chunk === undefined){\n        return\n      }else{\n        chunk = chunk + this.options.record_delimiter\n      }\n    }else{\n      chunk = this.stringify(chunk)\n      if(chunk === undefined){\n        return\n      }else{\n        if(this.options.header || this.info.records){\n          chunk = this.options.record_delimiter + chunk\n        }\n      }\n    }\n    // Emit the csv\n    this.info.records++\n    this.push(chunk)\n    callback()\n    null\n  }\n  _flush(callback){\n    if(this.info.records === 0){\n      this.headers()\n    }\n    callback()\n    null\n  }\n  stringify(chunk, chunkIsHeader=false){\n    if(typeof chunk !== 'object'){\n      return chunk\n    }\n    const {columns, header} = this.options\n    const record = []\n    // Record is an array\n    if(Array.isArray(chunk)){\n      // We are getting an array but the user has specified output columns. In\n      // this case, we respect the columns indexes\n      if(columns){\n        chunk.splice(columns.length)\n      }\n      // Cast record elements\n      for(let i=0; i<chunk.length; i++){\n        const field = chunk[i]\n        const [err, value] = this.__cast(field, {\n          index: i, column: i, records: this.info.records, header: chunkIsHeader\n        })\n        if(err){\n          this.emit('error', err)\n          return\n        }\n        record[i] = [value, field]\n      }\n    // Record is a literal object\n    }else{\n      if(columns){\n        for(let i=0; i<columns.length; i++){\n          const field = get(chunk, columns[i].key)\n          const [err, value] = this.__cast(field, {\n            index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader\n          })\n          if(err){\n            this.emit('error', err)\n            return\n          }\n          record[i] = [value, field]\n        }\n      }else{\n        for(let column of chunk){\n          const field = chunk[column]\n          const [err, value] = this.__cast(field, {\n            index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader\n          })\n          if(err){\n            this.emit('error', err)\n            return\n          }\n          record.push([value, field])\n        }\n      }\n    }\n    let csvrecord = ''\n    for(let i=0; i<record.length; i++){\n      let options, err\n      let [value, field] = record[i]\n      if(typeof value === \"string\"){\n        options = this.options\n      }else if(isObject(value)){\n        // let { value, ...options } = value\n        options = value\n        value = options.value\n        delete options.value\n        if(typeof value !== \"string\" && value !== undefined && value !== null){\n          this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`))\n          return\n        }\n        options = {...this.options, ...options}\n        if(err = this.normalize(options)){\n          this.emit(\"error\", err)\n          return\n        }\n      }else if(value === undefined || value === null){\n        options = this.options\n      }else{\n        this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`))\n        return\n      }\n      const {delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter} = options\n      if(value){\n        if(typeof value !== 'string'){\n          this.emit(\"error\", Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`))\n          return null\n        }\n        const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0\n        const containsQuote = (quote !== '') && value.indexOf(quote) >= 0\n        const containsEscape = value.indexOf(escape) >= 0 && (escape !== quote)\n        const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0\n        const quotedString = quoted_string && typeof field === 'string'\n        let quotedMatch = quoted_match && quoted_match.filter( quoted_match => {\n          if(typeof quoted_match === 'string'){\n            return value.indexOf(quoted_match) !== -1\n          }else{\n            return quoted_match.test(value)\n          }\n        })\n        quotedMatch = quotedMatch && quotedMatch.length > 0\n        const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch\n        if(shouldQuote === true && containsEscape === true){\n          const regexp = escape === '\\\\'\n          ? new RegExp(escape + escape, 'g')\n          : new RegExp(escape, 'g')\n          value = value.replace(regexp, escape + escape)\n        }\n        if(containsQuote === true){\n          const regexp = new RegExp(quote,'g')\n          value = value.replace(regexp, escape + quote)\n        }\n        if(shouldQuote === true){\n          value = quote + value + quote\n        }\n        csvrecord += value\n      }else if(quoted_empty === true || (field === '' && quoted_string === true && quoted_empty !== false)){\n        csvrecord += quote + quote\n      }\n      if(i !== record.length - 1){\n        csvrecord += delimiter\n      }\n    }\n    return csvrecord\n  }\n  headers(){\n    if(this.options.header === false){\n      return\n    }\n    if(this.options.columns === undefined){\n      return\n    }\n    let headers = this.options.columns.map(column => column.header)\n    if(this.options.eof){\n      headers = this.stringify(headers, true) + this.options.record_delimiter\n    }else{\n      headers = this.stringify(headers)\n    }\n    this.push(headers)\n  }\n  __cast(value, context){\n    const type = typeof value\n    try{\n      if(type === 'string'){ // Fine for 99% of the cases\n        return [undefined, this.options.cast.string(value, context)]\n      }else if(type === 'bigint'){\n        return [undefined, this.options.cast.bigint(value, context)]\n      }else if(type === 'number'){\n        return [undefined, this.options.cast.number(value, context)]\n      }else if(type === 'boolean'){\n        return [undefined, this.options.cast.boolean(value, context)]\n      }else if(value instanceof Date){\n        return [undefined, this.options.cast.date(value, context)]\n      }else if(type === 'object' && value !== null){\n        return [undefined, this.options.cast.object(value, context)]\n      }else{\n        return [undefined, value, value]\n      }\n    }catch(err){\n      return [err]\n    }\n  }\n  normalize_columns(columns){\n    if(columns === undefined || columns === null){\n      return undefined\n    }\n    if(typeof columns !== 'object'){\n      throw Error('Invalid option \"columns\": expect an array or an object')\n    }\n    if(!Array.isArray(columns)){\n      const newcolumns = []\n      for(let k in columns){\n        newcolumns.push({\n          key: k,\n          header: columns[k]\n        })\n      }\n      columns = newcolumns\n    }else{\n      const newcolumns = []\n      for(let column of columns){\n        if(typeof column === 'string'){\n          newcolumns.push({\n            key: column,\n            header: column\n          })\n        }else if(typeof column === 'object' && column !== undefined && !Array.isArray(column)){\n          if(!column.key){\n            throw Error('Invalid column definition: property \"key\" is required')\n          }\n          if(column.header === undefined){\n            column.header = column.key\n          }\n          newcolumns.push(column)\n        }else{\n          throw Error('Invalid column definition: expect a string or an object')\n        }\n      }\n      columns = newcolumns\n    }\n    return columns\n  }\n}\n\nconst stringify = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (Array.isArray(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ])\n    }\n  }\n  const stringifier = new Stringifier(options)\n  if(callback){\n    const chunks = []\n    stringifier.on('readable', function(){\n      let chunk\n      while((chunk = this.read()) !== null){\n        chunks.push(chunk)\n      }\n    })\n    stringifier.on('error', function(err){\n      callback(err)\n    })\n    stringifier.on('end', function(){\n      callback(undefined, chunks.join(''))\n    })\n  }\n  if(data !== undefined){\n    // Give a chance for events to be registered later\n    if(typeof setImmediate === 'function'){\n      setImmediate(function(){\n        for(let record of data){\n          stringifier.write(record)\n        }\n        stringifier.end()\n      })\n    }else{\n      for(let record of data){\n        stringifier.write(record)\n      }\n      stringifier.end()\n    }\n  }\n  return stringifier\n}\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ')\n    super(message)\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError)\n    }\n    this.code = code\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key]\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value))\n      }\n    }\n  }\n}\n\nstringify.Stringifier = Stringifier\n\nstringify.CsvError = CsvError\n\nmodule.exports = stringify\n\nconst isObject = function(obj){\n  return typeof obj === 'object' && obj !== null && ! Array.isArray(obj)\n}\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase()\n  })\n}\n\n// Lodash implementation of `get`\n\nconst charCodeOfDot = '.'.charCodeAt(0)\nconst reEscapeChar = /\\\\(\\\\)?/g\nconst rePropName = RegExp(\n  // Match anything that isn't a dot or bracket.\n  '[^.[\\\\]]+' + '|' +\n  // Or match property names within brackets.\n  '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n  ')\\\\]'+ '|' +\n  // Or match \"\" as the space between consecutive dots or empty brackets.\n  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n, 'g')\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/\nconst reIsPlainProp = /^\\w*$/\nconst getTag = function(value){\n  if(!value)\n    value === undefined ? '[object Undefined]' : '[object Null]'\n  return Object.prototype.toString.call(value)\n}\nconst isKey = function(value, object){\n  if(Array.isArray(value)){\n    return false\n  }\n  const type = typeof value\n  if(type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)){\n    return true\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object))\n}\nconst isSymbol = function(value){\n  const type = typeof value\n  return type === 'symbol' || (type === 'object' && value && getTag(value) === '[object Symbol]')\n}\nconst stringToPath = function(string){\n  const result = []\n  if(string.charCodeAt(0) === charCodeOfDot){\n    result.push('')\n  }\n  string.replace(rePropName, function(match, expression, quote, subString){\n    let key = match\n    if(quote){\n      key = subString.replace(reEscapeChar, '$1')\n    }else if(expression){\n      key = expression.trim()\n    }\n    result.push(key)\n  })\n  return result\n}\nconst castPath = function(value, object){\n  if(Array.isArray(value)){\n    return value\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value)\n  }\n}\nconst toKey = function(value){\n  if(typeof value === 'string' || isSymbol(value))\n    return value\n  const result = `${value}`\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result\n}\nconst get = function(object, path){\n  path = castPath(path, object)\n  let index = 0\n  const length = path.length\n  while(object != null && index < length){\n    object = object[toKey(path[index++])]\n  }\n  return (index && index === length) ? object : undefined\n}\n"]},"metadata":{},"sourceType":"script"}